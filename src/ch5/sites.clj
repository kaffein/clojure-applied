(ns ch5.sites)

;; WAITING FOR A RESPONSE
;; So far we have only experimented background work in a fire-and-forget fashion i.e
;; without waiting for a result back from the off-thread computation.
;; What now if we wanted to retrieve some results from those computations ?
;; Let's consider another example : let's say that Skynet wants to know the availability
;; of its time-machine in 3 different locations in order to decide from where to send
;; its terminators back in time.

(defn query
  "Returns the avaialability of time machine at a particular site"
  [site-name]
  (let [t (rand-int 2)]
    (Thread/sleep (* t 2000)) ;; "sleep the t1000" pun intended XD
    (if (zero? t)
      (str site-name " [NOK]")
      (str site-name " [OK]"))))

;; we could launch a query to 3 different sites this way :
(defn query-time-machine-sites
  [site-names]
  (for [site-name site-names]
    (query site-name)))

(query-time-machine-sites ["Los Angeles", "San Diego", "New York"])
;; but it would launch each query synchronously and the time it would take us to know
;; the avaialability of all sites would be the sum of the time needed to query each site

;; Instead, since we can now use `future`s, we can launch each query in asynchronously
;; in parallel reducing the time needed to retrieve all the results.
;; We could then refactor the `query-time-machine-sites` function like so :
(defn refactored-query-time-machine-sites
  [site-names]
  (for [site-name site-names]
    (future (query site-name))))

;; however this would return a lazy sequence of java.lang.Future and we then need to
;; deref each element in this sequence to retrieve the results.

;; We can then provide a third implementation with a slight variation regarding the way
;; we process the lazy sequence.
;; In fact, `for` returns a lazy sequence and thus will not launch the queries right away
;; but instead will wait for one of its element to be consumed (realized) to trigger the queries.
;; The idea here is then to `force` the realization of the sequence to trigger the 
;; launching of the queries generated by the `for` expressions right away. We will use
;; `doall` for that.

(defn eager-query-time-machine-sites
  [site-names]
  (let [futures (doall ;; this forces the triggering of the queries right away
                 (for [site-name site-names]
                   (future (query site-name))))]
    ;; retrieving the results consists now in derefing and blocking on each element
    (map deref futures)))

;; eval-ing those two expressions should give us a good idea of the advantages of having
;; the queries launched in parallel.
(eager-query-time-machine-sites ["Los Angeles", "San Diego", "New York"])
(query-time-machine-sites ["Los Angeles", "San Diego", "New York"])
;; The second expression should take something like 6 seconds to complete
